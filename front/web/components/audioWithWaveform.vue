<template>
  <div :class="[audioSource? '' : 'disabled']">
    <div class='waveform-container' ref="waveformContainer">
      <canvas :id="id" ref="canvas" v-on:mousedown="onCanvasMouseDown" v-on:mouseup="onCanvasMouseUp" v-on:mousemove="onCanvasMouseMove"></canvas>
      <span class='playhead' v-bind:style="{ left: timePositionPercent + '%', backgroundColor: playHeadColor }"></span>
    </div>
    <audio ref="player" controls=controls>
    </audio>
  </div>
</template>

<script>
import * as QuasarComponents from "quasar-framework";
export default {
  components: QuasarComponents,
  data() {
    return {
      message: "Oh hai from the component",
      id: null,
      audioSource: null,
      waveformData: null,
      player: null,
      timePositionPercent: 0,
      maxPeakValue: 128,
      colorBackground: "#FFF",
      colorPeaks: "#027BE3",
      playHeadColor: "#000",
      baseLineColor: "#FFF",
      timeSelectionColor: "rgba(0,0,0,0.3)",
      canvas: {
        element: null,
        ctx: null,
        update: true,
        updateInterval: 10,
        rect: null
      },
      timeSelectionFactor: {
        begin: 0,
        end: 0
      },
      mouse: {
        click: {
          x: null,
          y: null
        },
        drag: {
          x: null,
          y: null
        },
        current: {
          x: null,
          y: null
        },
        previous: {
          x: null,
          y: null
        },
        isDown: false,
        isDrag: false
      }
    };
  },
  props: {
    canTimeSelect: {
      default: false
    }
  },
  mounted() {
    console.log("canTimeSelect: " + this.canTimeSelect);
    this.id = this._uid;
    window.addEventListener("resize", this.resize, false);
    this.player = this.$refs.player;
    this.player.ontimeupdate = this.onPlayerTimeUpdate;
    this.canvas.element = this.$refs.canvas;
    this.canvas.ctx = this.canvas.element.getContext("2d");
    var canvas = document.getElementById(this.id);
    console.log(this.canvas.element);
    // setInterval(this.drawCanvas, this.canvas.updateInterval);
  },
  computed: {},
  methods: {
    uploadUrl: function() {
      console.log("upload url call");
      var url = "/upload/" + window.clientId;
      console.log(url);
      return url;
    },
    timeSelection() {
      if (!this.player) {
        return {
          begin: 0,
          end: 0
        };
      }
      var reverse =
        this.timeSelectionFactor.begin > this.timeSelectionFactor.end;
      var timeBegin = this.timeSelectionFactor.begin * this.player.duration;
      var timeEnd = this.timeSelectionFactor.end * this.player.duration;
      console.log(timeBegin, timeEnd);
      if (reverse) {
        return {
          begin: timeEnd,
          end: timeBegin
        };
      }

      return {
        begin: timeBegin,
        end: timeEnd
      };
    },
    clearTimeSelection(){
        this.timeSelectionFactor.begin = 0;
        this.timeSelectionFactor.end = 0;
        this.drawCanvas()
    },
    timeSelectionString() {
      return this.timeSelection().begin.toFixed(2) + "-" + this.timeSelection().end.toFixed(2);
    },
    timeSelectionRect() {
      var coords = [
        this.timeSelectionFactor.begin * this.canvas.width,
        0,
        (this.timeSelectionFactor.end - this.timeSelectionFactor.begin) *
          this.canvas.width,
        this.canvas.height
      ];
      console.log(coords);
      return coords;
    },
    canvasCoordsFromEvent(event) {
      var canvas = document.getElementById(this.id);
      var rect = canvas.getBoundingClientRect();
      return {
        x: event.pageX - rect.left,
        y: event.pageY - rect.top
      };
    },
    xFactorFromCoords(coords) {
      return coords.x / this.canvas.width;
    },
    resize() {
      this.canvas.update = true;
      this.drawCanvas();
    },
    onPlayerTimeUpdate() {
      console.log(this.player.currentTime);
      var currentTime = this.player.currentTime;
      var totalTime = this.player.duration;
      this.timePositionPercent = currentTime / totalTime * 100;
    },
    loadWaveformData(data) {
      this.waveformData = data;
      this.canvas.update = true;
      this.drawCanvas();
    },
    setAudioSource(audioSource) {
      console.log("setting source to " + audioSource);
      this.audioSource = audioSource;
      this.$refs.player.src = audioSource;
      this.$refs.player.load();
    },
    setWaveformSource(waveformSource) {
      var xhr = new XMLHttpRequest();
      // .dat file generated by audiowaveform program
      xhr.responseType = "arraybuffer";
      xhr.open("GET", waveformSource);

      xhr.addEventListener("load", progressEvent => {
        this.loadWaveformData(progressEvent.target.response);
      });

      xhr.send();
    },
    onCanvasMouseDown(event) {
      this.timeSelectionFactor.begin = this.xFactorFromCoords(
        this.canvasCoordsFromEvent(event)
      );
      this.mouse.isDown = true;
      console.log("mouseDown");
      this.mouse.current = {
        x: event.pageX,
        y: event.pageY
      };
      this.mouse.click = {
        x: event.pageX,
        y: event.pageY
      };
    },
    onCanvasMouseUp(event) {
      this.mouse.isDown = false;
      this.mouse.isDrag = false;
      console.log("mouseUp");
    },
    onCanvasMouseMove(event) {
      if (!this.canTimeSelect) return;
      this.mouse.current = {
        x: event.pageX,
        y: event.pageY
      };
      if (this.mouse.isDown) {
        this.timeSelectionFactor.end = this.xFactorFromCoords(
          this.canvasCoordsFromEvent(event)
        );
        this.$emit("timeselection", this.timeSelectionString());
        console.log("timeSelection", this.timeSelectionFactor);
        this.mouse.isDrag = true;
        this.mouse.drag = {
          x: event.pageX,
          y: event.pageY
        };
        this.canvas.update = true;
        this.drawCanvas();
        console.log("mouse drag");
      } else {
        console.log("mouseMove");
      }
    },
    drawCanvas() {
      if (!this.waveformData) return;

      var localWaveform = WaveformData.create(this.waveformData);

      var canvas = document.getElementById(this.id),
        context = canvas.getContext("2d");

      canvas.width = this.$refs.waveformContainer.clientWidth;
      canvas.height = this.$refs.waveformContainer.clientHeight;

      console.log(this.$refs.waveformContainer.clientWidth);
      this.canvas.width = this.$refs.waveformContainer.clientWidth;
      this.canvas.height = this.$refs.waveformContainer.clientHeight;

      this.canvas.ctx.fillStyle = this.colorBackground;
      this.canvas.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
      this.canvas.ctx.strokeStyle = this.colorPeaks;
      this.drawPeaks(localWaveform.min);
      this.drawPeaks(localWaveform.max);
      this.canvas.ctx.strokeStyle = this.baseLineColor;
      this.drawBaseLine();

      this.canvas.update = false;

      if (this.canTimeSelect) {
        this.canvas.ctx.moveTo(0, 0);
        this.canvas.ctx.beginPath();
        var coords = this.timeSelectionRect();
        console.log("rect");
        this.canvas.ctx.rect(...coords);
        this.canvas.ctx.fillStyle = this.timeSelectionColor;
        this.canvas.ctx.fill();
      }
    },
    drawBaseLine() {
      this.canvas.ctx.lineWidth = 1;
      this.canvas.ctx.beginPath();
      this.canvas.ctx.moveTo(0, this.canvas.height / 2);
      this.canvas.ctx.lineTo(this.canvas.width, this.canvas.height / 2);
      this.canvas.ctx.closePath();
      this.canvas.ctx.stroke();
    },
    drawPeaks(peaks) {
      var xFactor = this.canvas.width / peaks.length;
      this.canvas.ctx.beginPath();
      this.canvas.ctx.moveTo(0, this.canvas.height / 2);
      peaks.forEach((val, x) => {
        this.canvas.ctx.lineTo(
          x * xFactor,
          this.canvas.height * (0.5 + val / this.maxPeakValue / 2)
        );
      });

      this.canvas.ctx.lineWidth = 1;
      // filling with the same color. bbc's audiowaveform is.. buggy
      // when using 8 bits, with small files runs perfectly. with a large mp3 the peaks have a dc offset in the middle
      // so, filling with the same color to cover these.. artifacts
      this.canvas.ctx.fillStyle = this.canvas.ctx.strokeStyle;

      this.canvas.ctx.lineTo(this.canvas.width, this.canvas.height / 2);
      this.canvas.ctx.lineTo(0, this.canvas.height / 2);
      this.canvas.ctx.closePath();
      this.canvas.ctx.stroke();
      this.canvas.ctx.fill();
    },
    interpolateHeight(total_height) {
      const amplitude = 256;
      return size =>
        total_height -
        (size + this.canvas.height / 2) * total_height / amplitude;
    }
  }
};
</script>

<style scoped>
.disabled {
  /* display: none; */
  height: 0;
  overflow: hidden;
  opacity: 0.2;
}
p {
  background-color: red;
}
canvas {
  width: 100%;
}
.waveform-container {
  height: 200px;
  width: 100%;
  position: relative;
}
.playhead {
  display: inline-block;
  position: absolute;
  top: 0;
  height: 100%;
  width: 3px;
}
audio {
  width: 100%;
}
</style>